# 4.500w数据建立索引

假设一张表 500条万数据，通过 A 和  B 两个条件进行查询，A 条件可以过滤出 100万条数据，B 条件可以过滤出10 万条数据，那么这个索引应该怎么建。



对于这种情况，当查询条件是 `WHERE A = 'valueA' AND B = 'valueB'` 时，建立索引的关键在于将**选择性更高（能过滤掉更多数据）的列放在联合索引的前面**。

根据您提供的数据：

- 总数据量: 5亿条 (500万条 -> 应该是笔误，假设是 500 million，如果是 5 million，数量级不同，但原则一致)
- A 条件过滤后: 100万条数据 (选择性: 100万 / 5亿 = 1/500)
- B 条件过滤后: 10万条数据 (选择性: 10万 / 5亿 = 1/5000)

很明显，**B 条件的选择性更高** (1/5000 &lt; 1/500)，它能更大幅度地缩小查询范围。

因此，推荐的索引策略是：

**创建联合索引 (B, A)**

```SQL
CREATE INDEX idx_B_A ON your_table (B, A);
```

**为什么是 (B, A) 而不是 (A, B)？**

1. **索引扫描效率：**

   - 如果索引是 (B, A)： 
     1. 数据库首先使用索引 `B` 列的部分快速定位到满足 `B = 'valueB'` 的约10万条数据。
     2. 然后，在这10万条数据中（这些数据在索引中是按 `A` 排序的，或者至少是紧密排列的），再快速找到满足 `A = 'valueA'` 的数据。
   - 如果索引是 (A, B)： 
     1. 数据库首先使用索引 `A` 列的部分快速定位到满足 `A = 'valueA'` 的约100万条数据。
     2. 然后，在这100万条数据中，再查找满足 `B = 'valueB'` 的数据。

   显然，先通过 B 列将数据范围缩小到10万条，再进行下一步筛选，比先缩小到100万条再筛选要高效得多。数据库处理的数据量越少，速度越快。

2. **索引的最左前缀原则：**

   - 联合索引 

     ```
     (B, A)
     ```

      可以有效地支持以下查询： 

     - `WHERE B = 'valueB' AND A = 'valueA'`
     - `WHERE B = 'valueB'`

   - 联合索引 

     ```
     (A, B)
     ```

      可以有效地支持以下查询： 

     - `WHERE A = 'valueA' AND B = 'valueB'`
     - `WHERE A = 'valueA'`

   对于 `WHERE A = ? AND B = ?` 这样的查询，`(B,A)` 通常更好，因为 B 的选择性更高。

**其他考虑因素：**

1. **查询的列 (SELECT list):**

   - 如果您查询的列（比如 `SELECT C, D FROM your_table WHERE A = ? AND B = ?`）也包含在索引中，例如创建**覆盖索引 (Covering Index)** `(B, A, C, D)`，那么数据库可能只需要扫描索引就能获取所有需要的数据，无需回表查询，性能会进一步提升。但要注意，索引列越多，索引本身占用的空间越大，维护成本也越高。

2. **其他查询模式：**

   - 如果还有非常频繁的查询是 

     ```
     WHERE A = 'valueA'
     ```

     ，而 

     ```
     WHERE B = 'valueB'
     ```

      的查询不那么频繁或不存在，那么你可能需要权衡。 

     - 如果只有 `(B, A)` 索引，对于 `WHERE A = 'valueA'` 查询，索引 `(B, A)` 的效果会较差（除非数据库支持索引跳跃扫描 Index Skip Scan，但并非所有数据库或所有情况都高效）。
     - 这种情况下，你可能需要： 
       - 一个联合索引 `(B, A)` 用于 `AND` 查询。
       - 再额外创建一个单列索引 `(A)` 用于 `WHERE A = ?` 的查询。
       - 或者，如果 `WHERE A = ? AND B = ?` 的查询性能至关重要，且 `WHERE A = ?` 的查询允许稍慢，则只保留 `(B, A)`。

3. **等值查询 vs 范围查询：**

   - 上述建议主要针对等值查询 (`A = value`, `B = value`)。如果查询中包含范围查询（如 `A > value` 或 `B BETWEEN x AND y`），那么将等值查询的列放在联合索引的前面，范围查询的列放在后面，通常效果更好。如果 A 和 B 都是等值查询，则选择性高的放前面。

4. **实际测试：**

   - 理论分析很重要，但最终的索引效果还需通过 `EXPLAIN` (或特定数据库的执行计划分析工具) 来查看数据库实际是如何使用索引的，并进行实际的查询性能测试。

**总结：**

对于您描述的 `A 和 B 两个条件进行查询`（通常指 `AND` 连接），**首选创建联合索引 (B, A)**，因为 B 列具有更高的选择性。

如果还有其他常见的查询模式，可能需要额外的索引或调整联合索引的列顺序。