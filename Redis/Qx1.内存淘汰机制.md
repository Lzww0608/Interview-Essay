# Qx1.内存淘汰机制

## 内存淘汰策略

> `noeviction`

+ 当内存使用达到上限时，不再接受写入操作，返回错误信息。
+ 适用于只读操作多于写入操作的场景。

> `allkeys-lru`

- 使用 LRU (Least Recently Used) 算法，从所有键中淘汰最近最少使用的键。
- 适用于需要频繁访问最新数据的场景。

> `volatile-lru`

- 使用 LRU 算法，从设置了过期时间的键中淘汰最近最少使用的键。
- 适用于缓存场景，过期数据可以被淘汰。

> `allkeys-random`

- 随机淘汰所有键中的一个键。
- 适用于需要简单随机淘汰的场景。

> `allkeys-random`

- 随机淘汰所有键中的一个键。
- 适用于需要简单随机淘汰的场景。

> `volatile-ttl`

- 从设置了过期时间的键中淘汰 TTL（Time to Live）值最小的键，即最早过期的键。
- 适用于需要优先淘汰即将过期数据的场景。

> `volatile-lfu`

- 使用 LFU (Least Frequently Used) 算法，从设置了过期时间的键中淘汰使用频率最低的键。
- 适用于缓存场景，需要保留访问频率较高的数据。

> `allkeys-lfu`

- 使用 LFU 算法，从所有键中淘汰使用频率最低的键。
- 适用于需要保留访问频率较高的数据的场景。



## 配置内存淘汰策略

Redis 的内存淘汰策略通过配置文件 `redis.conf` 或启动参数进行设置。关键参数是 `maxmemory` 和 `maxmemory-policy`。

- `maxmemory`：设置 Redis 可使用的最大内存容量。例如：

```shell
maxmemory 2gb
```

- `maxmemory-policy`：设置内存淘汰策略。例如：

```shell
maxmemory-policy allkeys-lru
```



## 实现原理

### **LRU 算法**

LRU（Least Recently Used）算法是一种常用的缓存淘汰策略，旨在淘汰最近最少使用的键。Redis 通过维护一个链表或哈希表来记录每个键的访问时间，当内存达到上限时，淘汰链表尾部的键。

Redis 的 LRU 算法并非严格的 LRU，而是一种近似的 LRU。Redis 通过**采样**的方法，每次从若干个随机键中选择最近最少使用的键进行淘汰。这种方法在性能和准确性之间取得了平衡。



## **LFU 算法**

LFU（Least Frequently Used）算法旨在淘汰使用频率最低的键。Redis 通过为每个键维护一个访问计数器来实现 LFU 算法。每次访问键时，计数器递增；当内存达到上限时，淘汰计数器值最低的键。

类似 LRU，Redis 的 LFU 也是一种近似算法，通过**采样**来选择淘汰的键。



## **TTL 策略**

TTL（Time to Live）策略通过比较键的过期时间来决定淘汰顺序。Redis 维护每个键的过期时间，当内存达到上限时，淘汰过期时间最早的键。





## 应用场景

不同的内存淘汰策略适用于不同的应用场景：

1. **noeviction**：适用于只读操作多于写入操作的场景，如数据分析、日志查询等。
2. **allkeys-lru**：适用于需要频繁访问最新数据的场景，如社交媒体动态、新闻推送等。
3. **volatile-lru**：适用于缓存场景，过期数据可以被淘汰，如网页缓存、临时会话数据等。
4. **allkeys-random**：适用于需要简单随机淘汰的场景，如负载均衡、随机抽样等。
5. **volatile-random**：适用于缓存场景，过期数据可以被淘汰且对淘汰顺序要求不高，如短期缓存、临时数据存储等。
6. **volatile-ttl**：适用于需要优先淘汰即将过期数据的场景，如定时任务、过期数据清理等。
7. **volatile-lfu**：适用于缓存场景，需要保留访问频率较高的数据，如热点数据缓存、频繁访问的配置项等。
8. **allkeys-lfu**：适用于需要保留访问频率较高的数据的场景，如热门商品推荐、用户行为分析等。



## 性能优化

为了提升内存淘汰策略的性能，Redis 采用了一些优化措施：

1. **近似算法**：通过采样的方法，选择淘汰键时只从若干个随机键中选择，从而降低计算复杂度。

2. **定期清理**：Redis 定期检查过期键并进行清理，减少内存占用。
3. **渐进式淘汰**：当内存使用接近上限时，Redis 逐步增加淘汰频率，避免突发的内存淘汰操作导致性能抖动。



## 实际案例

以下是几个实际案例，展示了不同内存淘汰策略的应用：

**案例 1：社交媒体动态缓存**

在社交媒体应用中，需要频繁访问最新的动态数据。可以使用 `allkeys-lru` 策略，当内存达到上限时，淘汰最近最少使用的动态数据，确保用户能够快速访问最新的动态。

**案例 2：短期缓存**

在网页缓存或临时会话数据存储中，可以使用 `volatile-lru` 策略。当内存达到上限时，淘汰最近最少使用的过期数据，确保缓存空间的有效利用。

**案例 3：定时任务管理**

在定时任务管理系统中，可以使用 `volatile-ttl` 策略。当内存达到上限时，优先淘汰即将过期的任务数据，确保任务调度的准确性。

**案例 4：热点数据缓存**

在电子商务网站中，可以使用 `allkeys-lfu` 策略。当内存达到上限时，淘汰访问频率最低的商品数据，确保用户能够快速访问热门商品。