# Q85.非阻塞IO一定是异步IO吗？

### 非阻塞 I/O

非阻塞 I/O 是指在发起 I/O 操作时，调用立即返回，不会阻塞调用线程或进程。如果操作不能立即完成，系统会返回一个特定的错误（通常是 `EWOULDBLOCK` 或 `EAGAIN`），告诉调用者操作尚未完成，而不是等待操作完成。

#### 特点：

1. **立即返回**：调用立即返回，无需等待 I/O 操作完成。
2. **轮询机制**：调用者需要反复检查操作是否完成，通常使用轮询或循环检查。

#### 示例（伪代码）：

```go

// 伪代码示例
socket.set_nonblocking(true)
while !done {
    result = socket.read()
    if result == WOULD_BLOCK {
        // I/O 操作尚未完成，继续执行其他任务或重试
        continue
    } else {
        // I/O 操作完成，处理结果
        done = true
    }
}
```

### 异步 I/O

异步 I/O 是指发起 I/O 操作后，调用立即返回，并且系统会在操作完成时通知调用者，通常通过回调函数、事件或信号。异步 I/O 不需要调用者轮询检查操作是否完成，系统会主动通知调用者。

#### 特点：

1. **立即返回**：调用立即返回，无需等待 I/O 操作完成。
2. **事件驱动**：操作完成时，系统会通知调用者，不需要轮询。

#### 示例（伪代码）：

```go

// 伪代码示例
function on_io_complete(result) {
    // 处理 I/O 操作完成的结果
}

socket.read_async(on_io_complete)
// 调用立即返回，继续执行其他任务
```

### 区别与联系

- **非阻塞 I/O 不一定是异步 I/O**：非阻塞 I/O 只是确保调用立即返回，但调用者需要自己检查操作是否完成（例如，通过轮询）。异步 I/O 则是调用立即返回，系统会在操作完成时主动通知调用者，不需要调用者轮询。
- **异步 I/O 通常使用非阻塞 I/O 技术**：异步 I/O 实现中通常会使用非阻塞 I/O，以确保调用立即返回，并结合事件通知机制（如回调函数、信号或事件循环）在操作完成时通知调用者。

### 例子

- **非阻塞 I/O 示例**：一个网络服务器使用非阻塞套接字读取数据，但需要定期检查数据是否到达。
- **异步 I/O 示例**：一个文件读取操作在开始时立即返回，操作系统在文件读取完成后通过事件通知应用程序。

**总结**：

- 非阻塞 I/O 确保调用立即返回，但需要调用者主动检查操作完成状态。
- 异步 I/O 确保调用立即返回，并且系统会在操作完成时主动通知调用者。
- 非阻塞 I/O 可以用来实现异步 I/O，但两者的概念和实现方式不同。