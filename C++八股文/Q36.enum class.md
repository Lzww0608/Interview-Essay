# 为什么引入`enum class`

1. **类型安全Type Safety**: 传统的枚举类型不是类型安全的。这意味着枚举值可以与整数自由地互相转换，这可能导致类型错误而不被编译器检测到。`enum class` 通过提供更强的类型检查，改善了这个问题。Traditional enumerations are not type-safe. This means that enum values can freely convert to and from integers, potentially leading to type errors that are not be caught by the compiler. `enum class` can improve upon this by providing stronger type checking.
2. **命名空间污染Namespace Pollution**: 传统枚举的成员名字是在包含它们的作用域内直接可见的。这可能导致命名冲突。`enum class` 则需要使用枚举类名称作为作用域来访问其成员，这样减少了命名冲突的可能性。The member names of traditional enums are directly visible in the scope that contains them, which can lead to naming conflicts. `enum class`, on the other hand, need to use enum names as the scope to access their members, which reduce the possibility of naming conflicts.
3. **强作用域Stronger Scoping**: 正如之前提到的，`enum class` 成员需要通过枚举名称来限定，这提供了一个更强的作用域。这不仅避免了命名冲突，还提高了代码的可读性。As mentioned above, `enum class` members require qualification with enum names, providing a stronger scope. This not only avoids naming conflicts, but also enhances the readability of codes.
4. **明确的底层类型Explicit Underlying Type**: 在 C++11 中，你可以为 `enum class` 明确指定底层类型（比如 `int`, `short`, `unsigned int` 等）。这提供了更好的控制枚举类型的大小和性能，特别是在不同平台或编译器上。In C++11, you can specify an explicit underlying types for `enum class` (such as `int`, `short`, `unsigned int`, etc.). This offers better control over the size and performance of enum types, especially in different platforms or compliers.

