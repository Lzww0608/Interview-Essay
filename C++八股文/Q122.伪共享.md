# Q122.伪共享

### **伪共享（False Sharing）详解**

伪共享是多线程编程中一种**隐式性能问题**，它发生在多个CPU核心频繁修改**同一缓存行（Cache Line）中的不同数据**时，导致缓存一致性协议（如MESI）引发不必要的核间同步，从而大幅降低程序性能。

------

### **1. 核心概念**

#### **(1) 缓存行（Cache Line）**

- CPU缓存的最小单位（通常64字节，取决于架构）。
- 即使只修改1字节，整个缓存行也会被标记为"脏"并同步到其他核心。

#### **(2) 伪共享的产生条件**

- 不同线程修改**同一缓存行内的不同变量**。
- 这些线程运行在**不同的CPU核心**上。

#### **(3) 后果**

- 缓存行在核心间频繁无效化（Invalidation）。
- 实际无数据竞争，但性能类似共享变量（故名"伪共享"）。

------

### **2. 示例代码与问题复现**

#### **问题代码（C++）**

```cpp
struct Data {
    int x; // 线程1频繁修改
    int y; // 线程2频繁修改
};

Data data;

// 线程1（核心0）
void thread1() {
    for (int i = 0; i < 1e8; ++i) data.x++;
}

// 线程2（核心1）
void thread2() {
    for (int i = 0; i < 1e8; ++i) data.y++;
}
```

- `x`和`y`可能位于同一缓存行（假设`sizeof(Data)=8`，缓存行64字节）。
- 线程1修改`x` → 核心0的缓存行标记为"脏" → 核心1的对应缓存行无效化 → 线程2修改`y`时需重新从内存加载，周而复始。

------

### **3. 性能影响**

- **测试对比**（4核CPU，1亿次递增）：

  | 场景                             | 执行时间 |
  | :------------------------------- | :------- |
  | 无伪共享（`x`和`y`在不同缓存行） | 0.2秒    |
  | 存在伪共享                       | 2.1秒    |
  | **性能下降10倍！**               |          |

------

### **4. 解决方案**

#### **(1) 填充（Padding）**

```cpp
struct Data {
    int x;
    char padding[64]; // 确保x和y不在同一缓存行
    int y;
};
```

#### **(2) 对齐到缓存行**

```cpp
struct alignas(64) Data { // C++11起支持
    int x;
    int y;
};
```

#### **(3) 线程局部存储**

```cpp
thread_local int x; // 每个线程独立副本
thread_local int y;
```

#### **(4) 数组分块（适合循环）**

```
int data[2][64]; // data[0]和data[1]位于不同缓存行
```

------

### **5. 如何检测伪共享？**

- **工具**：
  - **Linux**: `perf c2c`（检测缓存行竞争）
  - **Windows**: VTune Profiler
- **现象**：
  - 多线程性能远低于预期。
  - 缓存未命中率（Cache Miss）异常高。

------

### **6. 实际案例优化**

#### **优化前（伪共享存在）**

```cpp
struct Counter {
    std::atomic<int> a, b; // a和b可能在同一缓存行
};
```

#### **优化后（消除伪共享）**

```cpp
struct Counter {
    alignas(64) std::atomic<int> a;
    alignas(64) std::atomic<int> b; // 强制分离缓存行
};
```

------

### **总结**

- **伪共享本质**：缓存一致性协议导致的无效同步。
- **适用场景**：高频修改的相邻小数据（如计数器、标志位）。
- **黄金法则**：高频修改的变量间隔至少一个缓存行（64字节）。