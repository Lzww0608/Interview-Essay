# Q97. dangling pointer

```c
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

先来看这样一段代码。这段代码虽然可以编译通过，但是其实非常糟糕，变量 `a` 和 `c` 都是局部变量，函数结束后将局部变量 `a` 的地址返回，但局部变量 `a` 存在栈中，在离开作用域后，`a` 所申请的栈上内存都会被系统回收，从而造成了 `悬空指针(Dangling Pointer)` 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误。



我们可以通过两种方式来修改：

**1. 返回动态分配的内存**：使用动态内存分配来分配`a`，确保返回的指针在函数结束后仍然有效。

```c++
int* foo() {
    int *a = new int;  // 动态分配内存
    *a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return a;
}  // 变量c的作用域结束
// 使用完指针后记得释放内存
```



**2. 使用静态变量**：如果合适的话，可以使用静态变量，但这有可能会导致线程安全问题。

```c++
int* foo() {
    static int a;     // 静态变量的生命周期为整个程序运行期间
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}  // 变量c的作用域结束
```

