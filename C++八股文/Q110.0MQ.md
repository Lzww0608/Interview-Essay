# Q110.0MQ

## 1. 发布订阅时如果高效地根据订阅条件过滤消息

字典树（前缀树）



## 2. 0MQ的特点和优势

+ **高性能**：**高效传输协议(TCP, IPC, INPROC) + 优化无锁队列(单读单写)**，实现低延迟和高吞吐，`Redis`的QPS大约11w， 0MQ可以达到80w。
+ **弹性与容错性**：断开自动重连，队列管理和负载均衡（简单轮循）
+ **通信模式**：请求/相应(REQ/REP)，发布/订阅(PUB/SUB)，流水线(PUSH/PULL)



## 3. 常见套接字类型及应用场景

+ `REQ/REP`
  + 客户端向服务端发起请求，并期望得到相应的同步交互模式，如RPC（同步）
+ `PUB/SUB`
  + 一对多消息分发，如实时广播数据、新闻推送、事件通知等。
+ `PUSH/PULL`
  + 多个工作者之间分配任务或者在流水线之间传递数据。
+ `ROUTER/DEALER`
  + 复杂的路由和分发场景



## 4. 如何实现异步请求连接

 `poll` 基于轮循



## 5. 如何实现断开重连和恢复通信

`tcp_connecter_t`负责重连， `ZMQ_RECONNECT_IVL`设置重连间隔，默认100ms，每次翻倍至`ZMQ_RECONNECT_IVL-MAX`默认1000ms（不设置则不翻倍）



## 6. 高水位标记（High Water Mark）

+ `PUB`和`ROUTER`中会丢弃消息，`DEALER`和`PUSH`会阻塞
+ `SUB`会丢弃，`PULL`和`DEALER`会拒绝并阻塞



## 7. 如何处理消息丢失和错误

发布订阅模式，设置合理的HWM，服务端发布数据的时机

**数据持久化**：发送之前持久化到本地存储，应答机制



## 8. 消息帧的概念





## 9. 高效性及原因

+ 无锁队列
+ 非阻塞I/O
+ 内存优化管理
+ 消息传递机制， 零拷贝机制`tcp_send`
+ 多种通信模式





## 10. 无锁队列的设计





## 11. 零拷贝技术

API可以直接从应用程序缓冲区发送和接收消息，而不需要复制数据

`zmq::msg_t::refcnt` `msg.cpp`



## 12. 消息可靠性实现





## 13. 负载均衡

基于轮循



## 14. PUB/SUB性能对比Redis





## 15. 实现简单分布式系统

15-taskwork2.c



## 16. 实战案例

金融交易系统

低延迟场景



## 17. 与Kafka对比

+ 架构问题
  + Kafka独立服务broker
  + 集成到项目代码
+ 消息存储
  + Kafka有持久化，商业用3个备份
  + zmq无持久化，需要自己设计
+ 消息顺序
  + Kafka同一分区保证消息顺序
  + 与模型有关， `REQ/REP`中无逻辑处理可以保证顺序